/* tslint:disable */
/* eslint-disable */
/**
 * VoidRun API
 * VoidRun API provides comprehensive management of virtual machines (sandboxes),  file system operations, execution environments, and organizational resources.  All endpoints except `/api/register` require the `X-API-Key` header for authentication. 
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  CreateFileRequest,
  ErrorResponse,
  ExecResponse,
  ListFiles200Response,
  StartWatch200Response,
  StartWatchRequest,
  SuccessResponse,
} from '../models/index';
import {
    CreateFileRequestFromJSON,
    CreateFileRequestToJSON,
    ErrorResponseFromJSON,
    ErrorResponseToJSON,
    ExecResponseFromJSON,
    ExecResponseToJSON,
    ListFiles200ResponseFromJSON,
    ListFiles200ResponseToJSON,
    StartWatch200ResponseFromJSON,
    StartWatch200ResponseToJSON,
    StartWatchRequestFromJSON,
    StartWatchRequestToJSON,
    SuccessResponseFromJSON,
    SuccessResponseToJSON,
} from '../models/index';

export interface ChangePermissionsRequest {
    id: string;
    path: string;
    mode: string;
}

export interface CompressFileRequest {
    id: string;
    path: string;
    format?: CompressFileFormatEnum;
}

export interface CopyFileRequest {
    id: string;
    from: string;
    to: string;
}

export interface CreateDirectoryRequest {
    id: string;
    path: string;
}

export interface CreateFileOperationRequest {
    id: string;
    path: string;
    content?: string;
    createFileRequest?: CreateFileRequest;
}

export interface DeleteFileRequest {
    id: string;
    path: string;
}

export interface DiskUsageRequest {
    id: string;
    path: string;
}

export interface DownloadFileRequest {
    id: string;
    path: string;
}

export interface ExtractArchiveRequest {
    id: string;
    archive: string;
    dest: string;
}

export interface HeadTailRequest {
    id: string;
    path: string;
    lines?: number;
    head?: boolean;
}

export interface ListFilesRequest {
    id: string;
    path: string;
}

export interface MoveFileRequest {
    id: string;
    from: string;
    to: string;
}

export interface SearchFilesRequest {
    id: string;
    path: string;
    pattern: string;
}

export interface StartWatchOperationRequest {
    id: string;
    startWatchRequest: StartWatchRequest;
}

export interface StatFileRequest {
    id: string;
    path: string;
}

export interface StreamWatchEventsRequest {
    id: string;
    sessionId: string;
}

export interface UploadFileRequest {
    id: string;
    path: string;
    body: Blob;
}

/**
 * 
 */
export class FileSystemApi extends runtime.BaseAPI {

    /**
     * Change the permissions (mode) of a file or directory
     * Change file permissions
     */
    async changePermissionsRaw(requestParameters: ChangePermissionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExecResponse>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling changePermissions().'
            );
        }

        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling changePermissions().'
            );
        }

        if (requestParameters['mode'] == null) {
            throw new runtime.RequiredError(
                'mode',
                'Required parameter "mode" was null or undefined when calling changePermissions().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['path'] != null) {
            queryParameters['path'] = requestParameters['path'];
        }

        if (requestParameters['mode'] != null) {
            queryParameters['mode'] = requestParameters['mode'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-API-Key"] = await this.configuration.apiKey("X-API-Key"); // ApiKeyAuth authentication
        }


        let urlPath = `/sandboxes/{id}/files/chmod`;
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ExecResponseFromJSON(jsonValue));
    }

    /**
     * Change the permissions (mode) of a file or directory
     * Change file permissions
     */
    async changePermissions(requestParameters: ChangePermissionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExecResponse> {
        const response = await this.changePermissionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create an archive from a file or directory
     * Compress file or directory
     */
    async compressFileRaw(requestParameters: CompressFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExecResponse>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling compressFile().'
            );
        }

        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling compressFile().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['path'] != null) {
            queryParameters['path'] = requestParameters['path'];
        }

        if (requestParameters['format'] != null) {
            queryParameters['format'] = requestParameters['format'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-API-Key"] = await this.configuration.apiKey("X-API-Key"); // ApiKeyAuth authentication
        }


        let urlPath = `/sandboxes/{id}/files/compress`;
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ExecResponseFromJSON(jsonValue));
    }

    /**
     * Create an archive from a file or directory
     * Compress file or directory
     */
    async compressFile(requestParameters: CompressFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExecResponse> {
        const response = await this.compressFileRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Copy a file or directory to a new location
     * Copy file or directory
     */
    async copyFileRaw(requestParameters: CopyFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExecResponse>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling copyFile().'
            );
        }

        if (requestParameters['from'] == null) {
            throw new runtime.RequiredError(
                'from',
                'Required parameter "from" was null or undefined when calling copyFile().'
            );
        }

        if (requestParameters['to'] == null) {
            throw new runtime.RequiredError(
                'to',
                'Required parameter "to" was null or undefined when calling copyFile().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['from'] != null) {
            queryParameters['from'] = requestParameters['from'];
        }

        if (requestParameters['to'] != null) {
            queryParameters['to'] = requestParameters['to'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-API-Key"] = await this.configuration.apiKey("X-API-Key"); // ApiKeyAuth authentication
        }


        let urlPath = `/sandboxes/{id}/files/copy`;
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ExecResponseFromJSON(jsonValue));
    }

    /**
     * Copy a file or directory to a new location
     * Copy file or directory
     */
    async copyFile(requestParameters: CopyFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExecResponse> {
        const response = await this.copyFileRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new directory
     * Create directory
     */
    async createDirectoryRaw(requestParameters: CreateDirectoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExecResponse>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling createDirectory().'
            );
        }

        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling createDirectory().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['path'] != null) {
            queryParameters['path'] = requestParameters['path'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-API-Key"] = await this.configuration.apiKey("X-API-Key"); // ApiKeyAuth authentication
        }


        let urlPath = `/sandboxes/{id}/files/mkdir`;
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ExecResponseFromJSON(jsonValue));
    }

    /**
     * Create a new directory
     * Create directory
     */
    async createDirectory(requestParameters: CreateDirectoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExecResponse> {
        const response = await this.createDirectoryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new file with optional content
     * Create file
     */
    async createFileRaw(requestParameters: CreateFileOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExecResponse>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling createFile().'
            );
        }

        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling createFile().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['path'] != null) {
            queryParameters['path'] = requestParameters['path'];
        }

        if (requestParameters['content'] != null) {
            queryParameters['content'] = requestParameters['content'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-API-Key"] = await this.configuration.apiKey("X-API-Key"); // ApiKeyAuth authentication
        }


        let urlPath = `/sandboxes/{id}/files/create`;
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateFileRequestToJSON(requestParameters['createFileRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ExecResponseFromJSON(jsonValue));
    }

    /**
     * Create a new file with optional content
     * Create file
     */
    async createFile(requestParameters: CreateFileOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExecResponse> {
        const response = await this.createFileRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a file or directory
     * Delete file or directory
     */
    async deleteFileRaw(requestParameters: DeleteFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExecResponse>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling deleteFile().'
            );
        }

        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling deleteFile().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['path'] != null) {
            queryParameters['path'] = requestParameters['path'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-API-Key"] = await this.configuration.apiKey("X-API-Key"); // ApiKeyAuth authentication
        }


        let urlPath = `/sandboxes/{id}/files`;
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ExecResponseFromJSON(jsonValue));
    }

    /**
     * Delete a file or directory
     * Delete file or directory
     */
    async deleteFile(requestParameters: DeleteFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExecResponse> {
        const response = await this.deleteFileRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get disk usage for a path
     * Disk usage
     */
    async diskUsageRaw(requestParameters: DiskUsageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExecResponse>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling diskUsage().'
            );
        }

        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling diskUsage().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['path'] != null) {
            queryParameters['path'] = requestParameters['path'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-API-Key"] = await this.configuration.apiKey("X-API-Key"); // ApiKeyAuth authentication
        }


        let urlPath = `/sandboxes/{id}/files/du`;
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ExecResponseFromJSON(jsonValue));
    }

    /**
     * Get disk usage for a path
     * Disk usage
     */
    async diskUsage(requestParameters: DiskUsageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExecResponse> {
        const response = await this.diskUsageRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Download a file from the sandbox
     * Download file
     */
    async downloadFileRaw(requestParameters: DownloadFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Blob>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling downloadFile().'
            );
        }

        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling downloadFile().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['path'] != null) {
            queryParameters['path'] = requestParameters['path'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-API-Key"] = await this.configuration.apiKey("X-API-Key"); // ApiKeyAuth authentication
        }


        let urlPath = `/sandboxes/{id}/files/download`;
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.BlobApiResponse(response);
    }

    /**
     * Download a file from the sandbox
     * Download file
     */
    async downloadFile(requestParameters: DownloadFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Blob> {
        const response = await this.downloadFileRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Extract an archive to a destination directory
     * Extract archive
     */
    async extractArchiveRaw(requestParameters: ExtractArchiveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExecResponse>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling extractArchive().'
            );
        }

        if (requestParameters['archive'] == null) {
            throw new runtime.RequiredError(
                'archive',
                'Required parameter "archive" was null or undefined when calling extractArchive().'
            );
        }

        if (requestParameters['dest'] == null) {
            throw new runtime.RequiredError(
                'dest',
                'Required parameter "dest" was null or undefined when calling extractArchive().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['archive'] != null) {
            queryParameters['archive'] = requestParameters['archive'];
        }

        if (requestParameters['dest'] != null) {
            queryParameters['dest'] = requestParameters['dest'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-API-Key"] = await this.configuration.apiKey("X-API-Key"); // ApiKeyAuth authentication
        }


        let urlPath = `/sandboxes/{id}/files/extract`;
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ExecResponseFromJSON(jsonValue));
    }

    /**
     * Extract an archive to a destination directory
     * Extract archive
     */
    async extractArchive(requestParameters: ExtractArchiveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExecResponse> {
        const response = await this.extractArchiveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the first or last N lines of a file
     * Read file head or tail
     */
    async headTailRaw(requestParameters: HeadTailRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExecResponse>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling headTail().'
            );
        }

        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling headTail().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['path'] != null) {
            queryParameters['path'] = requestParameters['path'];
        }

        if (requestParameters['lines'] != null) {
            queryParameters['lines'] = requestParameters['lines'];
        }

        if (requestParameters['head'] != null) {
            queryParameters['head'] = requestParameters['head'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-API-Key"] = await this.configuration.apiKey("X-API-Key"); // ApiKeyAuth authentication
        }


        let urlPath = `/sandboxes/{id}/files/head-tail`;
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ExecResponseFromJSON(jsonValue));
    }

    /**
     * Get the first or last N lines of a file
     * Read file head or tail
     */
    async headTail(requestParameters: HeadTailRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExecResponse> {
        const response = await this.headTailRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List files and directories in a path
     * List files
     */
    async listFilesRaw(requestParameters: ListFilesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListFiles200Response>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling listFiles().'
            );
        }

        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling listFiles().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['path'] != null) {
            queryParameters['path'] = requestParameters['path'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-API-Key"] = await this.configuration.apiKey("X-API-Key"); // ApiKeyAuth authentication
        }


        let urlPath = `/sandboxes/{id}/files`;
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ListFiles200ResponseFromJSON(jsonValue));
    }

    /**
     * List files and directories in a path
     * List files
     */
    async listFiles(requestParameters: ListFilesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListFiles200Response> {
        const response = await this.listFilesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Move or rename a file or directory
     * Move file or directory
     */
    async moveFileRaw(requestParameters: MoveFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExecResponse>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling moveFile().'
            );
        }

        if (requestParameters['from'] == null) {
            throw new runtime.RequiredError(
                'from',
                'Required parameter "from" was null or undefined when calling moveFile().'
            );
        }

        if (requestParameters['to'] == null) {
            throw new runtime.RequiredError(
                'to',
                'Required parameter "to" was null or undefined when calling moveFile().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['from'] != null) {
            queryParameters['from'] = requestParameters['from'];
        }

        if (requestParameters['to'] != null) {
            queryParameters['to'] = requestParameters['to'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-API-Key"] = await this.configuration.apiKey("X-API-Key"); // ApiKeyAuth authentication
        }


        let urlPath = `/sandboxes/{id}/files/move`;
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ExecResponseFromJSON(jsonValue));
    }

    /**
     * Move or rename a file or directory
     * Move file or directory
     */
    async moveFile(requestParameters: MoveFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExecResponse> {
        const response = await this.moveFileRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Search for files matching a pattern
     * Search files
     */
    async searchFilesRaw(requestParameters: SearchFilesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExecResponse>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling searchFiles().'
            );
        }

        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling searchFiles().'
            );
        }

        if (requestParameters['pattern'] == null) {
            throw new runtime.RequiredError(
                'pattern',
                'Required parameter "pattern" was null or undefined when calling searchFiles().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['path'] != null) {
            queryParameters['path'] = requestParameters['path'];
        }

        if (requestParameters['pattern'] != null) {
            queryParameters['pattern'] = requestParameters['pattern'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-API-Key"] = await this.configuration.apiKey("X-API-Key"); // ApiKeyAuth authentication
        }


        let urlPath = `/sandboxes/{id}/files/search`;
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ExecResponseFromJSON(jsonValue));
    }

    /**
     * Search for files matching a pattern
     * Search files
     */
    async searchFiles(requestParameters: SearchFilesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExecResponse> {
        const response = await this.searchFilesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Start monitoring a directory for file system events (create, modify, delete, rename) with optional recursion and hidden-dir filtering.
     * Start watching a directory
     */
    async startWatchRaw(requestParameters: StartWatchOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StartWatch200Response>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling startWatch().'
            );
        }

        if (requestParameters['startWatchRequest'] == null) {
            throw new runtime.RequiredError(
                'startWatchRequest',
                'Required parameter "startWatchRequest" was null or undefined when calling startWatch().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-API-Key"] = await this.configuration.apiKey("X-API-Key"); // ApiKeyAuth authentication
        }


        let urlPath = `/sandboxes/{id}/files/watch`;
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: StartWatchRequestToJSON(requestParameters['startWatchRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StartWatch200ResponseFromJSON(jsonValue));
    }

    /**
     * Start monitoring a directory for file system events (create, modify, delete, rename) with optional recursion and hidden-dir filtering.
     * Start watching a directory
     */
    async startWatch(requestParameters: StartWatchOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StartWatch200Response> {
        const response = await this.startWatchRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get detailed information about a file or directory
     * Get file stats
     */
    async statFileRaw(requestParameters: StatFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExecResponse>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling statFile().'
            );
        }

        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling statFile().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['path'] != null) {
            queryParameters['path'] = requestParameters['path'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-API-Key"] = await this.configuration.apiKey("X-API-Key"); // ApiKeyAuth authentication
        }


        let urlPath = `/sandboxes/{id}/files/stat`;
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ExecResponseFromJSON(jsonValue));
    }

    /**
     * Get detailed information about a file or directory
     * Get file stats
     */
    async statFile(requestParameters: StatFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExecResponse> {
        const response = await this.statFileRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * **RECOMMENDED:** Real-time WebSocket streaming of file system events.  Connect via WebSocket to receive events as they occur. This is more efficient than polling the `/events` endpoint and provides immediate notification of file system changes.  **WebSocket Protocol:** - Client connects to this endpoint - Server upgrades connection to WebSocket - Events are pushed to client as JSON objects - Connection stays open until client disconnects or session is stopped  **Event Format:** Each message is a FileEvent object (same as polling endpoint) 
     * Stream file watch events (WebSocket)
     */
    async streamWatchEventsRaw(requestParameters: StreamWatchEventsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling streamWatchEvents().'
            );
        }

        if (requestParameters['sessionId'] == null) {
            throw new runtime.RequiredError(
                'sessionId',
                'Required parameter "sessionId" was null or undefined when calling streamWatchEvents().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-API-Key"] = await this.configuration.apiKey("X-API-Key"); // ApiKeyAuth authentication
        }


        let urlPath = `/sandboxes/{id}/files/watch/{sessionId}/stream`;
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));
        urlPath = urlPath.replace(`{${"sessionId"}}`, encodeURIComponent(String(requestParameters['sessionId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * **RECOMMENDED:** Real-time WebSocket streaming of file system events.  Connect via WebSocket to receive events as they occur. This is more efficient than polling the `/events` endpoint and provides immediate notification of file system changes.  **WebSocket Protocol:** - Client connects to this endpoint - Server upgrades connection to WebSocket - Events are pushed to client as JSON objects - Connection stays open until client disconnects or session is stopped  **Event Format:** Each message is a FileEvent object (same as polling endpoint) 
     * Stream file watch events (WebSocket)
     */
    async streamWatchEvents(requestParameters: StreamWatchEventsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.streamWatchEventsRaw(requestParameters, initOverrides);
    }

    /**
     * Upload a file to the sandbox
     * Upload file
     */
    async uploadFileRaw(requestParameters: UploadFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SuccessResponse>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling uploadFile().'
            );
        }

        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling uploadFile().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling uploadFile().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['path'] != null) {
            queryParameters['path'] = requestParameters['path'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/octet-stream';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-API-Key"] = await this.configuration.apiKey("X-API-Key"); // ApiKeyAuth authentication
        }


        let urlPath = `/sandboxes/{id}/files/upload`;
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['body'] as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SuccessResponseFromJSON(jsonValue));
    }

    /**
     * Upload a file to the sandbox
     * Upload file
     */
    async uploadFile(requestParameters: UploadFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SuccessResponse> {
        const response = await this.uploadFileRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const CompressFileFormatEnum = {
    Tar: 'tar',
    TarGz: 'tar.gz',
    TarBz2: 'tar.bz2',
    Zip: 'zip'
} as const;
export type CompressFileFormatEnum = typeof CompressFileFormatEnum[keyof typeof CompressFileFormatEnum];
